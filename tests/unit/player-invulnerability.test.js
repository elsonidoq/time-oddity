import { jest } from '@jest/globals';
import { createPhaserSceneMock } from '../mocks/phaserSceneMock.js';
import Player from '../../client/src/entities/Player.js';

describe('Player Invulnerability System', () => {
  let scene;
  let player;

  beforeEach(() => {
    jest.useFakeTimers();
    
    // Prepare scene mock with time management
    scene = createPhaserSceneMock('GameScene');
    scene.time = {
      now: 1000,
      add: {
        delayedCall: jest.fn()
      }
    };
    
    // Attach registry for health tracking
    const internalStore = {};
    scene.registry = {
      set: jest.fn((key, value) => { internalStore[key] = value; }),
      get: jest.fn((key) => internalStore[key])
    };

    player = new Player(scene, 0, 0, 'placeholder_player', 0, 100);
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Invulnerability Properties', () => {
    test('should have invulnerability properties initialized', () => {
      expect(player.isInvulnerable).toBe(false);
      expect(player.invulnerabilityTimer).toBe(0);
      expect(player.invulnerabilityDuration).toBe(2000); // 2 seconds
    });

    test('should have isInvulnerable getter method', () => {
      expect(typeof player.isInvulnerable).toBe('boolean');
      expect(player.isInvulnerable).toBe(false);
    });
  });

  describe('takeDamage() - Invulnerability Activation', () => {
    test('should set invulnerability state when taking damage', () => {
      const initialHealth = player.health;
      
      player.takeDamage(10);
      
      expect(player.isInvulnerable).toBe(true);
      expect(player.invulnerabilityTimer).toBe(scene.time.now + 2000);
      expect(player.health).toBe(initialHealth - 10);
    });

    test('should prevent additional damage during invulnerability period', () => {
      const initialHealth = player.health;
      
      // First damage - should work and set invulnerability
      player.takeDamage(10);
      expect(player.health).toBe(initialHealth - 10);
      expect(player.isInvulnerable).toBe(true);
      
      // Second damage during invulnerability - should be ignored
      player.takeDamage(20);
      expect(player.health).toBe(initialHealth - 10); // Health unchanged
      expect(player.isInvulnerable).toBe(true);
    });

    test('should allow damage after invulnerability expires', () => {
      const initialHealth = player.health;
      
      // First damage
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      expect(player.health).toBe(initialHealth - 10);
      
      // Advance time past invulnerability duration
      scene.time.now += 2100; // 2.1 seconds
      player.update(scene.time.now, 16);
      
      // Should no longer be invulnerable
      expect(player.isInvulnerable).toBe(false);
      
      // Second damage should now work
      player.takeDamage(15);
      expect(player.health).toBe(initialHealth - 10 - 15);
      expect(player.isInvulnerable).toBe(true); // New invulnerability period
    });

    test('should reset invulnerability timer on new damage', () => {
      const initialHealth = player.health;
      
      // First damage
      player.takeDamage(10);
      const firstTimer = player.invulnerabilityTimer;
      expect(player.isInvulnerable).toBe(true);
      
      // Advance time but not enough to expire
      scene.time.now += 1000; // 1 second
      player.update(scene.time.now, 16);
      expect(player.isInvulnerable).toBe(true);
      
      // Second damage should reset timer
      player.takeDamage(5);
      expect(player.isInvulnerable).toBe(true);
      expect(player.invulnerabilityTimer).toBeGreaterThan(firstTimer);
      expect(player.health).toBe(initialHealth - 10); // Second damage ignored
    });
  });

  describe('update() - Invulnerability Timer Management', () => {
    test('should update invulnerability timer in update loop', () => {
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      
      // Advance time to just before expiration
      scene.time.now += 1990; // 1.99 seconds
      player.update(scene.time.now, 16);
      expect(player.isInvulnerable).toBe(true);
      
      // Advance time past expiration
      scene.time.now += 20; // 2.01 seconds total
      player.update(scene.time.now, 16);
      expect(player.isInvulnerable).toBe(false);
    });

    test('should handle multiple update calls correctly', () => {
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      
      // Multiple updates should not affect timer
      player.update(scene.time.now, 16);
      player.update(scene.time.now, 16);
      expect(player.isInvulnerable).toBe(true);
      
      // Advance time and update
      scene.time.now += 2000;
      player.update(scene.time.now, 16);
      expect(player.isInvulnerable).toBe(false);
    });
  });

  describe('Time Reversal Compatibility', () => {
    test('should preserve invulnerability state during time reversal', () => {
      // Set up TimeManager mock
      scene.timeManager = {
        isRewinding: false,
        managedObjects: new Set([player])
      };
      
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      
      // Simulate time reversal
      scene.timeManager.isRewinding = true;
      player.update(scene.time.now, 16);
      
      // Invulnerability state should be preserved during rewind
      expect(player.isInvulnerable).toBe(true);
    });

    test('should include invulnerability in state recording', () => {
      // Mock getStateForRecording to check if invulnerability is included
      const originalGetState = player.getStateForRecording;
      let recordedState = null;
      
      player.getStateForRecording = jest.fn(() => {
        const state = originalGetState ? originalGetState.call(player) : {
          x: player.x,
          y: player.y,
          velocityX: player.body?.velocity?.x || 0,
          velocityY: player.body?.velocity?.y || 0,
          animation: player.anims?.currentAnim?.key || null,
          isAlive: player.active !== false,
          isVisible: player.visible !== false
        };
        recordedState = state;
        return state;
      });
      
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      
      // Trigger state recording
      player.getStateForRecording();
      
      // Check that invulnerability state is included
      expect(recordedState).toBeDefined();
      // Note: The actual implementation will determine if invulnerability is included
      // in the base TemporalState or requires custom recording
    });
  });

  describe('Edge Cases', () => {
    test('should handle zero damage correctly', () => {
      const initialHealth = player.health;
      
      player.takeDamage(0);
      
      expect(player.health).toBe(initialHealth);
      expect(player.isInvulnerable).toBe(true); // Should still set invulnerability
    });

    test('should handle negative damage correctly', () => {
      const initialHealth = player.health;
      
      player.takeDamage(-10);
      
      expect(player.health).toBe(initialHealth); // Health should not change
      expect(player.isInvulnerable).toBe(true); // Should still set invulnerability
    });

    test('should handle scene without time manager', () => {
      delete scene.timeManager;
      
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      
      // Should not throw error during update
      expect(() => {
        player.update(scene.time.now, 16);
      }).not.toThrow();
    });

    test('should handle missing scene time', () => {
      delete scene.time;
      
      player.takeDamage(10);
      expect(player.isInvulnerable).toBe(true);
      
      // Should not throw error during update
      expect(() => {
        player.update(1000, 16);
      }).not.toThrow();
    });
  });

  describe('Integration with Existing Systems', () => {
    test('should maintain existing damage event emission', () => {
      const emitSpy = jest.spyOn(scene.events, 'emit');
      
      player.takeDamage(10);
      
      expect(emitSpy).toHaveBeenCalledWith('playerHealthChanged', {
        health: 90,
        damage: 10,
        previousHealth: 100
      });
    });

    test('should maintain existing health registry updates', () => {
      player.takeDamage(10);
      
      expect(scene.registry.set).toHaveBeenCalledWith('playerHealth', 90);
    });

    test('should maintain existing death event emission', () => {
      const emitSpy = jest.spyOn(scene.events, 'emit');
      
      // Kill the player
      player.takeDamage(100);
      
      expect(emitSpy).toHaveBeenCalledWith('playerDied', { player });
    });
  });
}); 